package xyz.haroldgao.sugarisa;

import org.junit.Assert;
import org.junit.Test;
import xyz.haroldgao.sugarisa.execute.ALUFlag;
import xyz.haroldgao.sugarisa.execute.ArchitecturalState;
import xyz.haroldgao.sugarisa.execute.Register;
import xyz.haroldgao.sugarisa.execute.SugarExecutor;

import java.util.function.Predicate;

/**
 * Some of these tests were generated by ChatGPT (because they are tedious to write and do not require brain-cells.)
 * Methods generated using AI will be labeled as such.
 * */
public class IntegrationTest {

    @Test
    public void testSetter(){
        test("r0 = r0;", new int[]{0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0});
        test("r0 = 0xabc;", new int[]{0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0});
        test("r1 = 0xabc;", new int[]{0,0xabc,0,0,0,0,0,0,0,0,0,0,0,0,4,0});
        test("r1 = 0xabc;r0 = r1;", new int[]{0,0xabc,0,0,0,0,0,0,0,0,0,0,0,0,8,0});
        test("r1 = 0xabc;r2 = r1;", new int[]{0,0xabc,0xabc,0,0,0,0,0,0,0,0,0,0,0,8,0});
        test("r1 = 0xabc;pc=12;r2 = r1;r3=r1;", new int[]{0,0xabc,0,0xabc,0,0,0,0,0,0,0,0,0,0,16,0});
    }

    @Test
    public void testNot(){
        test("r1=7;!r1;", new int[]{0,-8,0,0,0,0,0,0,0,0,0,0,0,0,8,0});
        test("r1=7;sp = !r1;", new int[]{0,7,0,0,0,0,0,0,0,0,0,0,0,0,8,-8});
        test("r0 = !0x0;", new int[]{0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0});
    }

    /**
     * This test case was generated by AI.
     * */
    @Test
    public void testArithmetic(){
        // Original test
        test("r1 = 5; r2 = r1 + 6; r3 = r1 + r2; r3 += r1;",
                new int[]{0,5,11,21,0,0,0,0,0,0,0,0,0,0,16,0});

        // Subtraction with immediate
        test("r1 = 20; r2 = r1 - 5;",
                new int[]{0,20,15,0,0,0,0,0,0,0,0,0,0,0,8,0});

        // Subtraction with register
        test("r1 = 20; r2 = 5; r3 = r1 - r2;",
                new int[]{0,20,5,15,0,0,0,0,0,0,0,0,0,0,12,0});

        // Multiplication
        test("r1 = 4; r2 = 6; r3 = r1 * r2;",
                new int[]{0,4,6,24,0,0,0,0,0,0,0,0,0,0,12,0});

        // Division
        test("r1 = 24; r2 = 6; r3 = r1 / r2;",
                new int[]{0,24,6,4,0,0,0,0,0,0,0,0,0,0,12,0});

        // Division by immediate
        test("r1 = 25; r2 = r1 / 5;",
                new int[]{0,25,5,0,0,0,0,0,0,0,0,0,0,0,8,0});

        // Modulo
        test("r1 = 23; r2 = 5; r3 = r1 % r2;",
                new int[]{0,23,5,3,0,0,0,0,0,0,0,0,0,0,12,0});

        // Mixed operations
        test("r1 = 10; r2 = 2; r3 = r1 + r2; r4 = r3 * 3; r4 -= r2;",
                new int[]{0,10,2,12,34,0,0,0,0,0,0,0,0,0,20,0});

        // Combined immediate and register
        test("r1 = 7; r2 = r1 * 5; r3 = r2 + 3; r3 /= 2;",
                new int[]{0,7,35,19,0,0,0,0,0,0,0,0,0,0,16,0});

        // Negative results (subtraction)
        test("r1 = 5; r2 = 10; r3 = r1 - r2;",
                new int[]{0,5,10,-5,0,0,0,0,0,0,0,0,0,0,12,0});
    }


    @Test
    public void testStack(){

        test("""
                r1 = 123;
                push r1;
                """, new int[]{0,123,0,0,0,0,0,0,0,0,0,0,0,0,8,0xFFFFFFFC}
        );

        test("""
                r1 = 1;
                r2 = 3;
                r3 = 4;
                push r1;
                push r2;
                push r3;
                pop r1;
                pop r2;
                pop r3;
                """, new int[]{0,4,3,1,0,0,0,0,0,0,0,0,0,0,36,0});
    }

    @Test
    public void testFlags(){
        test("r0 += r0 -> flag;", a -> a.readFlag(ALUFlag.Z));
        test("r1 = 3; r2 = 3; r1 -= r2 -> flag;", a -> a.readFlag(ALUFlag.Z));
        test("r1 = 12; r2 = r1 % 6 -> flag;", a -> a.readFlag(ALUFlag.Z));
        test("r1 -= 1 -> flag;", a -> a.readFlag(ALUFlag.N) && !a.readFlag(ALUFlag.Z));
        test("compare r1, r2;", a -> a.readFlag(ALUFlag.Z));
        test("r1 = 3; r2 = 4; compare r1, r2;", a -> a.readFlag(ALUFlag.N));
        test("r1 = 0b1; r1 << 31; r1 -= 3000 -> flag;", a -> a.readFlag(ALUFlag.V));
        test("r10 = 0b1; r10 << 31; !r10; r10 += 1 -> flag;", a -> a.readFlag(ALUFlag.V));
        test("r1 = 10;r2=12;r3 = r1 - r2 -> flag;", a -> a.readFlag(ALUFlag.C));
        test("r1 -= 1; r1 += 1 -> flag;", a -> a.readFlag(ALUFlag.C));
    }

    @Test
    public void testLogical(){
        test("r1 = 0b1101; r2 = 0b0111; r3 = r1 & r2;", new int[]{
                0, 13, 7, 5,0,0,0,0,0,0,0,0,0,0,12,0
        });
        test("r1 = 0b1101; r2 = 0b0111; r3 = r1 | r2;", new int[]{
                0, 13, 7, 15,0,0,0,0,0,0,0,0,0,0,12,0
        });
        test("r1 = 0b1101; r2 = 0b0111; r3 = r1 ^ r2;", new int[]{
                0, 13, 7, 10,0,0,0,0,0,0,0,0,0,0,12,0
        });
        test("r1 = 0b1101; r2 = r1 << 3;", new int[]{
                0, 13, 104, 0,0,0,0,0,0,0,0,0,0,0,8,0
        });

        test("r1 = 0b1101; r2 = r1 >> 1;", new int[]{
                0, 13, 6, 0,0,0,0,0,0,0,0,0,0,0,8,0
        });

        test("r1 = 0b1001; r2 = r1 & 0b0110 -> flag;", a -> a.readFlag(ALUFlag.Z));
    }

    @Test
    public void testCall(){
        test("""
                MAIN:
                    r1 = 2;
                    call FUNCTION;
                    r1 = 3;
                FUNCTION:
                    r2 = 3;
                """, new int[]{
                0, 2, 3, 0,0,0,0,0,0,0,0,0,0,8,16,0
        });

        test("""
                MAIN:
                    r1 = 2;
                    call FUNCTION;
                    r3 = 4;
                    goto END;
                FUNCTION:
                    r2 = 3;
                    return;
                END:
                    ;
                """, new int[]{
                0, 2, 3, 4,0,0,0,0,0,0,0,0,0,8,28,0
        });

        test("""
                MAIN:
                    r1 = 2;
                    call FUNCTION;
                    r3 = 4;
                    call END;
                FUNCTION:
                    r2 = 3;
                    return;
                END:
                    ;
                """, new int[]{
                0, 2, 3, 4,0,0,0,0,0,0,0,0,0,16,28,0
        });

        test("""
                MAIN:
                    push lr;            //0
                    call INCREMENT;     //4
                    call INCREMENT;     //8
                    call INCREMENT;     //12
                    pop lr;             //16
                    goto END;           //20
                INCREMENT:
                    push lr;            //24
                    call INCREMENT_R1;  //28
                    call INCREMENT_R2;  //32
                    call INCREMENT_R3;  //36
                    pop lr;             //40
                    return;             //44
                INCREMENT_R1:
                    r1 += 1;            //48
                    return;             //52
                INCREMENT_R2:
                    r2 += 1;            //56
                    return;             //60
                INCREMENT_R3:
                    r3 += 1;            //64
                    return;             //68
                END:
                    ;                   //72
                """, new int[]{
                0, 3, 3, 3,0,0,0,0,0,0,0,0,0,0,76,0
        });

    }

    @Test
    public void testMemory(){

        //standard offsets

        test("r1 = 0xFFFF; r2 = 123; [r1] = r2; r3 = [r1];",
                a -> a.read(0xFFFF) == 123);

        test("r1 = 0xFFFF; r2 = 123; [r1] = r2; r3 = [r1];",
                new int[]{0, 0xFFFF, 123, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0});

        test("r1 = 100; r2 = 5; r3 = 99; [r1 + r2] = r3; r11 = 150; r10 -= 45; r4 = [r11 + r10];",
                new int[]{0, 100, 5, 99, 99, 0, 0, 0, 0, 0, -45, 150, 0, 0, 28, 0});

        test("r1 = 100; r2 = 200; r3 -= 999; [r1 + 50] = r3; r4 = [r2 - 50];",
                new int[]{0, 100, 200, -999, -999, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0});



        // Post-Offset
        test("""
                r1 = 0xFF; //address
                r2 = 100; //value
                [r1] = r2 -> r1 += 16;
                r3 = [r1 - 16];
                """, new int[]{0, 0xFF + 16, 100, 100,0,0,0,0,0,0,0,0,0,0,16,0});

        test("""
                r1 = 0xFF; //address
                r2 = 100; //value
                r4 = 200;
                [r1] = r2 -> r1 += r4;
                r3 = [r1 - 200];
                """, new int[]{0, 0xFF + 200, 100, 100,200,0,0,0,0,0,0,0,0,0,20,0});

        test("""
                r1 = 0xFF; //address
                r2 = 100; //value
                [r1] = r2 -> r1 -= 16;
                r3 = [r1 + 16];
                """, new int[]{0, 0xFF - 16, 100, 100,0,0,0,0,0,0,0,0,0,0,16,0});

        // Pre-Offset
        test("""
                 r1 = 0x100;
                 r2 = 11;
                 r3 -= 16;
                 r1 -= 4 -> [r1] =r2; // [0xFC] = 11
                 r2 += 1;
                 r1 -= 8 -> [r1] = r2; // [0xF4] = 12
                 r2 += 1;
                 r1 += r3 -> [r1] = r2; // [0xe4] = 13
                 r2 += 1;
                 r1 += 12 -> [r1] = r2; // [0xf0] = 14
                 
                 r1 = 0xFC;
                 r2 = 0xF4;
                 r3 = 0xe4;
                 r4 = 0xf0;
                 
                 r1 = [r1];
                 r2 = [r2];
                 r3 = [r3];
                 r4 = [r4];
                 """, a ->
                                            a.read(Register.R1) == 11
                                         && a.read(Register.R2) == 12
                                         && a.read(Register.R3) == 13
                                         && a.read(Register.R4) == 14
                );

    }

    @Test
    public void testCondBranch(){
        test("""
                compare r0, r0;
                gotoz SET_2;
                goto END;
                SET_2:
                    r1 = 2;
                END:
                    ;
                """,
                a -> a.read(Register.R1) == 2
        );

        test("""
                r1 = 2;
                compare r0, r1;
                goton SET_3;
                goto END;
                SET_3:
                    r1 = 3;
                END:
                    ;
                """,
                a -> a.read(Register.R1) == 3
        );

        test("""
                goton END;
                r1 = 2;
                END: 
                    ;
                """,
                a -> a.read(Register.R1) == 2
        );

        test("""
                gotoz END;
                r1 = 2;
                END: 
                    ;
                """,
                a -> a.read(Register.R1) == 2
        );

        test("""
                gotoc END;
                r1 = 2;
                END: 
                    ;
                """,
                a -> a.read(Register.R1) == 2
        );

        test("""
                gotov END;
                r1 = 2;
                END: 
                    ;
                """,
                a -> a.read(Register.R1) == 2
        );

        test("""
                r1 = 0b0111111111111111;
                r1 << 16;
                r1 |= 0xFFFF;
                r1 += 1 -> flag;
                gotov END;
                r2 = 2;
                END: 
                    ;
                """,
                a -> a.read(Register.R2) == 0
        );

        test("""
                r1 = 0b1111111111111111;
                r1 << 16;
                r1 |= 0xFFFF;
                r1 += 1 -> flag;
                gotoc END;
                r2 = 2;
                END: 
                    ;
                """,
                a -> a.read(Register.R2) == 0
        );

    }


    @Test
    public void sumOfArray(){
        String assembly = """
                    MAIN:
                        push lr;
                        r1 = 0xFFFC;
                        r2 = 109;
                        r1 += 4 -> [r1] = r2;
                        r2 = 122;
                        r1 += 4 -> [r1] = r2;
                        r2 = 0;
                        r2 -= 5;
                        r1 += 4 -> [r1] = r2;
                        r3 = 4;
                        r2 = 912;
                        r1 += r3 -> [r1] = r2;
                        r2 = 122;
                        r1 += r3 -> [r1] = r2;
                        r1 = 0xFFFF;
                        r1 += 1;
                        r2 = 5;
                        call SUM_OF_ARRAY;
                        pop lr;
                        goto END;
                    
                    //r1 is a pointer to the start of the array.
                    //r2 is the size of the array.
                    //Returns the sum of elements in the array.
                    SUM_OF_ARRAY:
                        r5 = 0; //count;
                        r3 = 0; //sum
                        LOOP:
                            compare r5, r2;
                            gotoz END_LOOP;
                            r4 = [r1] -> r1 += 4;
                            r3 += r4;
                            r5 += 1;
                            goto LOOP;
                        END_LOOP:
                        r1 = r3;
                    
                    END:
                        ;

                """;

        test(assembly, a -> a.read(Register.R1) == 1260);
    }

    @Test(timeout = 3000)
    public void factorial(){
        String assembly = """
                MAIN:
                    push lr;
                
                    r1 = 10;
                    call FAC;
                    goto END;
                
                // r1 holds n, returns n! through r1. 
                FAC:
                    push lr;
                    r2 = 2;
                    compare r1, r2;
                    goton BASE_CASE;
                    
                    push r1;
                    r1 -= 1;
                    call FAC;
                    pop r2;
                    r1 *= r2;
                    
                    pop lr;
                    return;
                    
                    BASE_CASE:
                        r1 = 1;
                        pop lr;
                        return;
                
                END:
                    pop lr;
                """;

        test(assembly, a -> a.read(Register.R1) == 3628800);
    }

    @Test
    public void fib(){
        String assembly = """
                MAIN:
                    push lr;
                    r1 = 19;
                    call FIB;
                    pop lr;
                    goto END;
                
                // r1 contains n, calculates the n'th fibonacci number.
                // Uses dynamic programming.
                // Returns -1 if an overflow occurs.
                FIB:
                    r2 = 0x10000;
                    r3 = 3;
                    compare r1, r0;
                    gotoz ZERO_CASE;
                    compare r1, r3;
                    goton ONE_CASE;
                
                    r1 -= 2;
                
                    r3 = 0;
                    [r2] = r3 -> r2 += 4;
                    r3 = 1;
                    [r2] = r3 -> r2 += 4;
                    [r2] = r3;
                
                    LOOP:
                        compare r1, r0;
                        gotoz RECURSIVE_CASE;
                
                        r3 = [r2 - 4];
                        r4 = [r2];
                        r3 += r4 -> flag;
                        gotov OVERFLOW_CASE;
                        r2 += 4 -> [r2] = r3;
                
                        r1 -= 1;
                        goto LOOP;
                
                
                    RECURSIVE_CASE:
                        r1 = [r2];
                        return;
                
                    OVERFLOW_CASE:
                        r1 = 0;
                        r1 -= 1;
                        return;
                
                    ZERO_CASE:
                        r1 = 0;
                        return;
                
                    ONE_CASE:
                        r1 = 1;
                        return;
                
                
                END:
                    ;
     
                """;

        test(assembly, a -> a.read(Register.R1) == 4181);


        String assembly2 = """
                MAIN:
                    push lr;
                    r1 = 3200;
                    call FIB;
                    pop lr;
                    goto END;
                
                // r1 contains n, calculates the n'th fibonacci number.
                // Uses dynamic programming.
                // Returns -1 if an overflow occurs.
                FIB:
                    r2 = 0x10000;
                    r3 = 3;
                    compare r1, r0;
                    gotoz ZERO_CASE;
                    compare r1, r3;
                    goton ONE_CASE;
                
                    r1 -= 2;
                
                    r3 = 0;
                    [r2] = r3 -> r2 += 4;
                    r3 = 1;
                    [r2] = r3 -> r2 += 4;
                    [r2] = r3;
                
                    LOOP:
                        compare r1, r0;
                        gotoz RECURSIVE_CASE;
                
                        r3 = [r2 - 4];
                        r4 = [r2];
                        r3 += r4 -> flag;
                        gotov OVERFLOW_CASE;
                        r2 += 4 -> [r2] = r3;
                
                        r1 -= 1;
                        goto LOOP;
                
                
                    RECURSIVE_CASE:
                        r1 = [r2];
                        return;
                
                    OVERFLOW_CASE:
                        r1 = 0;
                        r1 -= 1;
                        return;
                
                    ZERO_CASE:
                        r1 = 0;
                        return;
                
                    ONE_CASE:
                        r1 = 1;
                        return;
                
                
                END:
                    ;
     
                """;

        test(assembly2, a -> a.read(Register.R1) == -1);
    }

    public void test(String assembly, int[] registerFile){
        test(assembly, a -> {
            for (int i = 0; i < Register.values().length; i++) {
                if(registerFile[i] != a.read(Register.values()[i])) return false;
            }
            return true;
        });
    }

    public void test(String assembly, Predicate<ArchitecturalState> assertion){
        ArchitecturalState a = SugarExecutor.load(assembly).execute();
//        System.out.println(a.getRegisterFileString());
        Assert.assertTrue(a.getRegisterFileString(), assertion.test(a));
    }

}
